{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"kindaxml","text":"<p>KindaXML is a tolerant, XML-ish annotation DSL for LLM output. It favors predictable recovery over strict well-formedness, producing a flat stream of annotated text segments and zero-width markers.</p>"},{"location":"#quickstart-rust","title":"Quickstart (Rust)","text":"<pre><code>use kindaxml::{parse, ParserConfig, UnknownMode};\n\nfn main() {\n    let mut cfg = ParserConfig::default();\n    cfg.recognized_tags = [\"cite\", \"note\"].into_iter().map(String::from).collect();\n    cfg.case_sensitive_tags = false;\n    cfg.unknown_mode = UnknownMode::Strip;\n\n    let input = \"We shipped &lt;cite id=1&gt;last week&lt;/cite&gt;.\";\n    let parsed = parse(input, &amp;cfg);\n\n    for segment in parsed.segments {\n        println!(\"{:?} -&gt; {:?}\", segment.text, segment.annotations);\n    }\n}\n</code></pre>"},{"location":"#quickstart-python","title":"Quickstart (Python)","text":"<pre><code>from kindaxml import parse, ParserConfig\n\ncfg = ParserConfig()\ncfg.set_recognized_tags([\"cite\", \"note\"])\ncfg.set_unknown_mode(\"strip\")\n\nparsed = parse(\"We shipped &lt;cite id=1&gt;last week&lt;/cite&gt;.\", cfg)\nprint(parsed.text)\n</code></pre>"},{"location":"#what-to-read-next","title":"What to read next","text":"<ul> <li>Concepts: how the model is represented and why it is tolerant.</li> <li>Modes: how unknown tags and recovery strategies are configured.</li> <li>Examples: runnable examples with expected output.</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>KindaXML is designed to annotate text without building a deep DOM. The parser emits a flat list of text segments and optional markers, recovering from common model mistakes.</p>"},{"location":"concepts/#core-ideas","title":"Core ideas","text":"<ul> <li>Annotation-first: tags annotate text spans rather than create nested trees.</li> <li>Deterministic recovery: malformed tags still map to predictable spans.</li> <li>Shallow structure: open tags auto-close when the next tag starts to avoid runaway nesting.</li> </ul>"},{"location":"concepts/#output-model","title":"Output model","text":"<p>The parser returns:</p> <ul> <li><code>text</code>: tag-stripped text</li> <li><code>segments</code>: ordered runs of text, each with zero or more annotations</li> <li><code>markers</code>: zero-width annotations for self-closing tags</li> </ul> <p>Example (conceptual):</p> <pre><code>[\n  {\"text\": \"We shipped \", \"annotations\": []},\n  {\"text\": \"last week\", \"annotations\": [{\"tag\": \"cite\", \"attrs\": {\"id\": \"1\"}}]},\n  {\"text\": \".\", \"annotations\": []}\n]\n</code></pre>"},{"location":"concepts/#runnable-example","title":"Runnable example","text":"<p>Run:</p> <pre><code>cargo run -q --example basic\n</code></pre> <p>Expected output (excerpt):</p> <pre><code>=== Inline span ===\nOriginal text:\nWe shipped &lt;cite id=\"1\"&gt;last week&lt;/cite&gt;.\n\nParsed text:\nWe shipped last week.\nSegments:\n- 'We shipped '\n- 'last week' (cite [id=\"1\"])\n- '.'\n</code></pre> <p>CI tip: compare the excerpt above with the matching section in the command output to verify the annotation model.</p>"},{"location":"modes/","title":"Modes","text":"<p>Modes control how KindaXML recovers from malformed input and how it treats unknown tags.</p>"},{"location":"modes/#unknown-tag-handling","title":"Unknown tag handling","text":"<p><code>UnknownMode</code> determines what happens when the parser sees a tag that is not in <code>recognized_tags</code>:</p> <ul> <li><code>Strip</code>: remove the tag markup but keep inner text</li> <li><code>Passthrough</code>: keep the literal tag markup in the output text</li> <li><code>TreatAsText</code>: do not treat <code>&lt;...&gt;</code> as a tag at all</li> </ul>"},{"location":"modes/#recovery-strategies","title":"Recovery strategies","text":"<p>Unclosed tags use <code>RecoveryStrategy</code> (configurable per tag):</p> <ul> <li><code>RetroLine</code>: annotate text on the same line before the tag</li> <li><code>ForwardUntilTag</code>: annotate until the next tag start</li> <li><code>ForwardUntilNewline</code>: annotate until the next newline</li> <li><code>ForwardNextToken</code>: annotate the next token only</li> <li><code>Noop</code>: ignore the unclosed tag</li> </ul>"},{"location":"modes/#autoclose-and-stray-end-tags","title":"Autoclose and stray end tags","text":"<ul> <li><code>autoclose_on_any_tag</code>: close open tags when any new tag starts</li> <li><code>autoclose_on_same_tag</code>: close an open tag if the same tag appears again</li> <li><code>stray_end_tag_policy</code>: drop or passthrough unmatched end tags</li> </ul>"},{"location":"examples/basic/","title":"Basic example","text":"<p>This page mirrors <code>examples/basic.rs</code> and shows the full output for easy CI verification.</p>"},{"location":"examples/basic/#what-this-example-demonstrates","title":"What this example demonstrates","text":"<ul> <li><code>inline</code> spans with explicit end tags</li> <li><code>retro_line</code> recovery for unclosed citations</li> <li><code>forward_next_token</code> for risk tags</li> <li>self-closing markers for <code>todo</code></li> </ul>"},{"location":"examples/basic/#how-to-run","title":"How to run","text":"<p>Run:</p> <pre><code>cargo run -q --example basic\n</code></pre>"},{"location":"examples/quick-examples/","title":"Input -&gt; parsed (1-to-1)","text":"<p>Each subsection shows the original input snippet and the exact parsed output from the example.</p>"},{"location":"examples/quick-examples/#inline-span-explicit-close","title":"Inline span (explicit close)","text":"<p>Showing how  tags are parsed and annotated. <p>Parse settings: default, aka:  <pre><code>ParserConfig(\n   recognized_tags=['cite'],\n   unknown_mode='strip',\n   per_tag_recovery={'cite': retro_line},\n   trim_punctuation=true,\n   autoclose_on_any_tag=true,\n   autoclose_on_same_tag=true,\n   case_sensitive_tags=false\n)\n</code></pre></p> Input<p><p> <pre><code>We shipped &lt;cite id=1&gt;last week&lt;/cite&gt;.\n</code></pre> </p></p>Rendered Output<p><p>We shipped last week.</p></p> <p></p> <p>Technical detail: the <code>cite</code> tag is recognized and closed normally, so the annotation applies only to the inner span.</p>"},{"location":"examples/quick-examples/#tag-annotations","title":"Tag annotations","text":"<p>All tags annotations support with quoted attributes, boolean attributes, and multiple attributes.</p> <p>Parse settings: Tag annotations can have multiple attributes, including boolean attributes (no value), with or without quotes., aka:  <pre><code>ParserConfig(\n   recognized_tags=['tag'],\n   unknown_mode='strip',\n   per_tag_recovery={},\n   trim_punctuation=true,\n   autoclose_on_any_tag=true,\n   autoclose_on_same_tag=true,\n   case_sensitive_tags=true\n)\n</code></pre></p> Input<p><p> <pre><code>Words can have &lt;tag a=1 b='two' c d=\"4\"&gt;multiple attributes&lt;/tag&gt;. Word can also have &lt;tag 59=42 9000&gt;number as attribute&lt;/tag&gt;. Attribute &lt;tag no=quote&gt;without&lt;/tag&gt; quotation mark works, and there will be best-effort to auto-close &lt;tag att='one two three&gt;un-closed quotation marks&lt;/tag&gt;. Unrecognized tags are &lt;unknown foo=bar&gt;auto dropped&lt;/unknown&gt; with the default config.\n</code></pre> </p></p>Rendered Output<p><p>Words can have multiple attributes. Word can also have number as attribute. Attribute without quotation mark works, and there will be best-effort to auto-close un-closed quotation marks. Unrecognized tags are auto dropped with the default config.</p></p> <p></p> <p>Technical detail: <code>risk</code> is configured with <code>forward_next_token</code>, so only the next token is annotated for the second tag. Whereas <code>mytag</code> uses <code>retro_line</code>, so it attaches backward to the start of the line.</p>"},{"location":"examples/quick-examples/#retroactive-cite-unclosed-auto-close","title":"Retroactive cite (unclosed + auto-close)","text":"<p>Showing how unclosed  tags are handled. <p>Parse settings: default, aka:  <pre><code>ParserConfig(\n   recognized_tags=['cite'],\n   unknown_mode='strip',\n   per_tag_recovery={'cite': retro_line},\n   trim_punctuation=true,\n   autoclose_on_any_tag=true,\n   autoclose_on_same_tag=true,\n   case_sensitive_tags=false\n)\n</code></pre></p> Input<p><p> <pre><code>We shipped last week &lt;cite id=1&gt;. More info &lt;note&gt;soon.\n</code></pre> </p></p>Rendered Output<p><p>We shipped last week . More info soon.</p></p> <p></p> <p>Technical detail: <code>cite</code> is configured with <code>retro_line</code>, so the unclosed tag attaches backward on the same line up to the tag start. The following <code>&lt;note&gt;</code> triggers auto-close behavior, because it reaches the end of the line.</p>"},{"location":"examples/quick-examples/#forward-token-per-tag-strategy","title":"Forward token (per-tag strategy)","text":"<p>Setting individual tag recovery strategies.</p> <p>Parse settings: <code>risk</code> recovery strategy set to <code>forward_next_token</code>, aka:  <pre><code>ParserConfig(\n   recognized_tags=['mytag', 'risk'],\n   unknown_mode='strip',\n   per_tag_recovery={'mytag': retro_line, 'risk': forward_next_token},\n   trim_punctuation=true,\n   autoclose_on_any_tag=true,\n   autoclose_on_same_tag=true,\n   case_sensitive_tags=true\n)\n</code></pre></p> Input<p><p> <pre><code>Risks: &lt;mytag level=high&gt; load tests are late. &lt;risk level=low&gt;Docs slipping.\n</code></pre> </p></p>Rendered Output<p><p>Risks:  load tests are late. Docs slipping.</p></p> <p></p> <p>Technical detail: <code>risk</code> is configured with <code>forward_next_token</code>, so only the next token is annotated for the second tag. Whereas <code>mytag</code> uses <code>retro_line</code>, so it attaches backward to the start of the line.</p>"},{"location":"examples/quick-examples/#self-closing-markers","title":"Self-closing markers","text":"<p>Using self-closing tags will emit zero-width markers.</p> <p>Parse settings: default, aka:  <pre><code>ParserConfig(\n   recognized_tags=['todo'],\n   unknown_mode='strip',\n   per_tag_recovery={},\n   trim_punctuation=true,\n   autoclose_on_any_tag=true,\n   autoclose_on_same_tag=true,\n   case_sensitive_tags=true\n)\n</code></pre></p> Input<p><p> <pre><code>Todo list: &lt;todo id=7/&gt;finish rollout &lt;todo/&gt; update docs.\n</code></pre> </p></p>Rendered Output<p><p>Todo list: _finish rollout _ update docs.</p></p> <p></p> <p>Technical detail: Self-closing `` tags emit zero-width markers at their positions instead of annotating a span.</p> <p></p>"}]}